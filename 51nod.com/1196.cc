/**
 * http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1196
 * 字符串的数量
 * 思路：动态规划，曹鹏的答案
 *
 * 比较喜欢这个题。
下面的所有字母编号都从1开始，范围1..n。

首先，一个合法的字符串显然是由若干个合法的“链”组成的。链的定义就是：从一个字母开始连，后面每个字母编号必须大于等于前一个的2倍，这样尽可能的连接下去。所谓尽可能连接下去的意思是，链的最后一个字母编号i必须满足2 * i > n ，这样后面不能接东西了，并且只有这样的链才合法。对于每个合法字符串，划分成合法链的方法是唯一的。
比如 N = 2 M = 3的3个解 分别是 (ab)(b)， (b)(ab)， (b)(b)(b)
问题转化为两步：
(1)  g(x)表示长度为x的合法链的个数，求g(x)
(2)  v(x)表示长度为x的合法字符串数，求v(x)
对于(2) 显然我们有v(x) = g(1) * v(x - 1) + g(2) * v(x - 2) +...+g(p) * v(x - p)
就是长度为x的解可以先弄出一条链来，再构造剩余的部分。为方便可以定义v(0) = 1,这样单独一条长度为x的合法链也是合法解。 其中p是最长的合法链的长度。
用这个式子直接推长度为m的结果复杂度是O(m * p)。
显然，当有n种字母的时候，p是O(logn)级别的。所以这部分复杂度是O(m*logn) 在m,n 比较小的时候这部分复杂度可以了。
优化：
很显然的 可以用矩阵优化它。 假设我们知道V = (v(0),v(2),....v(p - 1)) 弄一个p * p 的矩阵M出来 让V * M 恰好等于(v(1),v(2)...v(p)) 这样每乘一次这样的矩阵，相当于求出一个新的v值。这个比较像fib数的矩阵方法，只是矩阵不是2*2的，而是p*p的，那么问题转化为求这个矩阵的m次方。 矩阵乘法是O(p^3)的再m次方，于是复杂度是O(p^3 * log m) = O((logn)^3 * logm)的。这部分复杂度已经足够低了……但是还有办法优化。因为这个矩阵比较特殊，有很多0……，有个论文的方法讲了，这个矩阵幂最后可以优化到O((logn)^2 * logm)的。
这部分比较简单。关键是(1)不好求。
对于(1)
假设我们定义 f(len, x)表示以编号为x的字母开头的长度为len的合法链个数，那么有
f(len, x) = f(len - 1, x * 2) + f(len - 1, x * 2 + 1) +....+f(len - 1, n)
即f(len, x) = sigma(f(len - 1, y))   y 遍历从2 * x 到 n
那么，我们直接用这个式子很容易得到一个 O(p * n)的算法求得所有f(len,x)，进而求出g(x)。p仍然是最长合法链的长度，所以复杂度是O(n * logn)。 空间上，可以对len那一维使用滚动数组，变成优化到O(n)。这对于比较小的n足够了，v2,v3应该不能这么搞。
优化：
   我们先看一下f(1,x)
   f(1,x) = 0       if 2 * x <= n  即 1 <= x <= n / 2
   f(1,x) = 1       if 2 * x > n    即  n / 2  + 1 <= x <= n
可见f(1,x)是个分段函数，我们假设f(L,x)是个分段函数，满足如下形式
f(L, x) = p1(x) if  1 <= x <= a
f(L, x) = p2(x) if  a + 1 <= x <= b
其余区间都是0值
其中p1(x), p2(x)是关于x的多项式，事实上它们是x的(L - 1)次多项式。
那么，我们看一下f(L + 1, x)的形式
由定义 我们需要看一下2 * x落到的区间范围 累加
当 a + 1 <= 2 * x <= b 时 f(L + 1, x) = sigma p2(y) 其中y 遍历从2 * x 到 b
当1 <= 2 * x <= a时  f(L + 1, x) = sigma(p1(y1)) + sigma(p2(y2)) 其中y1遍历从2 * x到a, y2遍历从(a + 1)到b  （其实后半部分是个常数和x无关的）
我们发现f(L + 1, x)也是一个分段函数……
后面我的方法原理简单，但是实现很麻烦。
就是求自然数k次方的和的表达式
即求sum1(x) = 1 + 2 +...+x = x * (x + 1) / 2
      sum2(x) = 1 ^ 2 + 2 ^2 +...+x ^ 2 = x * (x + 1) * (2x + 1) / 6
      sum3(x) =....
这个可以通过组合数等方法预处理出来，对于自然数从1到x的p次方的和，是关于x的(p+1)次方的多项式。全部预处理的复杂度O(p^3)。如果系数有分数的话，我们可以用10^9 + 7的逆元处理掉……因为10^9 + 7是质数，很方便。
那么回到上面那个问题，如果p1, p2都是关于x的(L - 1)次多项式的话，理论上我们可以求出它的任意区间和，具体做法是把每个n^i,我们都求区间和，区间[p,q]的和，等于从1加到q的和与从1加到(p - 1)的和的差，这个就能用之前预处理的那么多sum(x)来搞定。总之，对于任意多项式的任意区间和，我们都可以求出。跟x相关的比较麻烦，因为需要用(2x - 1)代换x求差，当然这个用组合数什么的都可以解决。

于是，我们发现f(L + 1, x)也是个分段函数，并且每段上是关于x的L次多项式。
这样，理论上我们可以求出所有的f(len,x)
进而，g(len) = sigma(f(len,x)) x from 1.. n 这个也可以求出，就是f(len,x)在两个分段上的和而已。
这部分复杂度，首先，分段函数的个数是O(logn)的。
每个分段函数的多项式次数是O(logn)的。
求区间和的时候，需要对这O(logn)的n^i这样的东西求区间和，因为每个区间和是（i + 1）次多项式，直接带入求值的话，复杂度是O(i)。于是，对每个分段函数的多项式求区间和复杂度是O((logn)^2)。
求出所有分段函数的函数形式总复杂度是O((logn)^3)。

如果两部分都优化好的话，（1）的复杂度是O((logn)^3) (2)的复杂度是O((logn)^2 * logm)
总的复杂度是 O((logn)^2*(logn + logm)) 这个复杂度应该可以过v2 v3了。
 *
 *

 **/

#include <stdio.h>

#define P 1000000007

int main() {

    int n, m;
    int half0, half1;
    int dp0, dp1;

    scanf( "%d%d", &n, &m );

    dp0 = half0 = n / 2;
    dp1 = half1 = n - n / 2;

    for( int i = 2; i <= m; ++i ) {
        int tmp0 = (long long) dp1 * half0 % P;
        int tmp1 = (long long) ( dp0 + dp1 ) * half1 % P;
        dp0 = tmp0;
        dp1 = tmp1;
    }

    printf( "%d\n", dp1 );

    return 0;
}
