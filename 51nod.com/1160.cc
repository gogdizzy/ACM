/**
*  http://51nod.com/onlineJudge/questionCode.html#!problemId=1160
*  压缩算法的矩阵 V2
*  参考答案：http://51nod.com/question/index.html#!questionId=45
*  思路：朴素作法是每次将最后一列放到第一列，然后将字符串排序（排序，是按照前k个已知字符）
*        只要前面已知的字符是有序的，那么最后一列一定和已知的是一致的。
*            ????1
*            ????1    
*  原始矩阵  ????0
*            ????0
*            ????0
*
*   1????    0???1    10???    00??1    100??    001?1    1001?    00101
*   1????    0???1    10???    01??1    101??    010?1    1010?    01001
*   0???? => 0???0 => 00??? => 01??0 => 001?? => 010?0 => 0010? => 01010
*   0????    1???0    01???    10??0    010??    100?0    0100?    10010
*   0????    1???0    01???    10??0    010??    101?0    0101?    10100
*
*  每次排序，排序后和排序前，每个元素有一个映射关系。
*  因为每一次都在第一列加上最后一列的数据，而第一列是“最显著列”，是排序时的第一要素。
*  所以考虑能不能每次只考虑第一列排序时的映射关系呢？使得每次新的映射完成后，无需排序。
*  答案是可以。映射关系定义为对第一列稳定排序的映射。
*  可以用归纳法证明：
*    1 初始：第一次对第一列排序，第一列是有序的。
*    2 归纳：假设前k列已知字符是有序的，在前面插入最后一列，然后进行稳定排序，可以知道，除非第一列
*       大小不同会交换，如果相同不会交换，即k+1列仍然是有序的。
*
*  所以我们只要记住最后一列稳定排序的映射关系就可以知道后续的关系了。
*  求最后一列稳定排序的映射关系，因为序列里只有0和1，所以类似于鸽笼排序，从前到后扫描一遍即可。
*
*  知道了映射，我们再来看一下，假设原来矩阵第一行是ABCDE，最后一列是11000
*    根据最后一列稳定排序的映射关系，可以得出下表
*          -------------------------------
*          |  排序前索引  |  排序后索引  |
*          |-----------------------------|
*          |      0       |      3       |
*          |      1       |      4       |
*          |      2       |      0       |
*          |      3       |      1       |
*          |      4       |      2       |
*          -------------------------------
*    因为最后一列已知，它是由倒数第二列通过这个映射关系得来的，所以我们只需要逆着推就行了。
*    我们考察E的位置，并把E所在的行补全。
*
*   ABCDE    ABCDE    ABCDE    ABCDE    ABCDE
*   ?????    ?????    ?????    DEABC    DEABC
*   ????? => BCDEA => BCDEA => BCDEA => BCDEA
*   ?????    ?????    ?????    ?????    EABCD
*   ?????    ?????    CDEAB    CDEAB    CDEAB
*
*    E=1      A=0      B=0      C=1      D=0
*
*   这个推导过程中，E所在列是逐渐往左推的，它每次往左走一列，相当于他后面又补了一个数字。
*   根据ABCDE的循环关系，E的后面逐渐补的恰好就是ABCD，也就是根据每次E所在的行的最后一位数字，
*   就可以推出ABCD是多少了。
*
*/

#include <stdio.h>

#define  MAXN  500001

char  input[MAXN];
char  output[MAXN];
int   map[MAXN];

int  count1( char* str ) {
	int  cnt = 0;
	while( *str ) cnt += *str++ - '0';
	return  cnt;
}

int main() {
	int  n, i, j, idx0, idx1, c1;
	scanf( "%d%s", &n, input );
	c1 = count1( input );
	idx0 = 0; idx1 = n - c1;
	for( i = 0; i < n; ++i ) map[ input[i] == '0' ? idx0++ : idx1++ ] = i;
	for( i = 0, j = map[0]; i < n; ++i, j = map[j] ) output[i] = input[j]; 
	output[n] = '\0';
	if( c1 != count1( output ) ) puts( "No Solution" );
	else puts( output );
	return 0;
}